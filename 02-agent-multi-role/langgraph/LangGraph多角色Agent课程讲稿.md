# AI旅行Agent：基于LangGraph实战多角色智能体协作（讲稿·初学者友好版）

## 面向对象
- 初学者；具备基础 Python 能力；首次接触 Agent/LLM 编排与 LangGraph。

## 课程产出
- 搭建一个可运行的多角色旅行助手（规划、搜索、推荐、汇总）。
- 掌握 LangGraph 的 StateGraph、条件路由、Agent 循环、记忆、断点、人类介入、并行与子图。

---

## 0. 章节导览（5min）
- 目标：理解从单 Agent 到多 Agent 的学习路径与编码主线。
- 要点：
  - 基础（StateGraph/节点/边）→ 工具链与消息 → 条件路由与循环 → 记忆与状态 → 人类介入与时间旅行 → 并行与子图 → 项目整合。
  - 产出一览：每节有可运行 Notebook 与任务清单。

备注（代码/资料）：`README.md` 项目结构与启动方式。

---

## 1. 主流框架选型（20min）
- 学习目标：理解 LangGraph vs CrewAI vs AutoGen 的定位与取舍，能做项目级选型。
- 讲解要点：
  - LangGraph：强编排与可视化调试、状态与断点、时间旅行，适合生产级流程与人机混合。
  - CrewAI：任务编队与角色分工简单上手，流程抽象较高。
  - AutoGen：会话式多 Agent，侧重对话驱动协作。
- 适用建议：需要“强状态、强可控、强调试”的企业级流程，优先 LangGraph。

备注（资料）：`0-docs/` 对比文档与框架背景。

---

## 2. StateGraph 最小可用图（20min）
- 学习目标：能创建最小图，理解节点、边、运行流程。
- 步骤：
  1) 定义状态结构  2) 定义节点函数  3) 连接边  4) 运行图
- 关键认知：每个节点只读/写自己关注的状态字段，图以“入口节点→边→出口/END”顺序执行。

备注（Notebook）：`1-Base/01-simple-graph.ipynb`

---

## 3. 消息链与工具集成（20min）
- 学习目标：会把 LLM 与工具封装成节点，按链路串联。
- 要点：消息是状态的字段；每个节点只关心自己消费/产出的字段。上游产出即下游输入。

备注：`1-Base/02-chain.ipynb`

---

## 4. 条件路由与 Agent 循环（各20min）
- 学习目标：根据状态做分支，支持多步决策与循环工具调用。
- 要点：通过“条件边”函数返回目标节点或 END；循环通过条件再次指向上游节点实现。

备注：`1-Base/03-router.ipynb`，`1-Base/04-agent.ipynb`

---

## 5. Agent 记忆：维护对话上下文（20min）
- 学习目标：把历史消息纳入状态，形成可持续对话。
- 要点：消息列表放入状态字段，节点读取/追加。

备注：`1-Base/05-agent-memory.ipynb`

---

## 6. 结构化状态与 Reducer（各20min）
- 学习目标：使用 TypedDict/Pydantic 定义状态；用 Reducer 合并并发更新。
- 要点：
  - 多节点并发写同一字段 → Reducer 负责合并策略（例如 append/overwrite/merge by key）。
  - 为多角色 Agent 定义分层状态：局部状态与共享状态。

备注：`2-StateAndMemory/01-state-schema.ipynb`，`02-state-reducers.ipynb`，`03-multiple-schemas.ipynb`

---

## 7. 消息修剪与摘要记忆（20min）
- 学习目标：通过修剪/摘要延长多轮对话能力，控制上下文长度与成本。
- 要点：限制历史长度（基于轮次/Token 粗估）+ 定期生成摘要写回状态；摘要与最近 K 条消息共同作为上下文。

备注：`2-StateAndMemory/04-trim-filter-messages.ipynb`，`06-chatbot-summarization.ipynb`

---

## 8. 外部记忆：持久化会话（20min）
- 学习目标：把对话与摘要写入 SQLite/Redis 等，支持长时间、多会话恢复。
- 关键点：会话 id、时间戳、消息表结构、读写抽象。

备注：`2-StateAndMemory/05-chatbot-external-memory.ipynb`

---

## 9. 流式交互与人类介入（各20min）
- 学习目标：
  - astream 监控运行过程与 token 流；
  - 设置断点、审批节点，引入人类放行；
  - 运行中编辑状态与动态断点。
- 讲解顺序：
  1) 流式输出观察执行轨迹  2) 设置关键节点断点  3) 运行时修改状态与条件。

备注：`3-HumanInTheLoop/01-streaming-interruption.ipynb`，`02-breakpoints.ipynb`，`03-edit-state-human-feedback.ipynb`，`04-dynamic-breakpoints.ipynb`

---

## 10. 时间旅行调试（20min）
- 学习目标：回放历史、创建分叉，快速定位问题与回归测试。

备注：`3-HumanInTheLoop/05-time-travel.ipynb`

---

## 11. 并行执行优化实战：提升多Agent吞吐能力（20min）
- 学习目标：
  - Map/扇出：多个工具/角色并行工作；
  - Reduce/扇入：合并结果；
  - 通过并行策略显著提升端到端任务吞吐与时延表现。
- 要点：
  - 扇出：并行调度多个独立节点（如酒店/美食/景点检索）；
  - 扇入：以 Reducer/汇总节点统一合并为结构化输出，定义确定性的合并/去重/排序规则；
  - 观测：通过运行轨迹与状态快照验证无竞态、无重复与一致性。

备注：`4-BuildYourAssiant/01-parallelization.ipynb`

---

## 12. 项目实战4：LangGraph子图协同实现多Agent模块化编排（20min）
- 学习目标：
  - 子图：把一段流程封装成可复用组件，边界清晰、易于组合；
  - 子图协同：通过局部状态与边界 I/O 实现跨模块通信与装配；
  - 模块化治理：便于单元测试、灰度替换与团队协作。

- 场景设定（与笔记本对应）：
  - 有一批原始日志 `raw_logs` 需“问题汇总”（QS）与“失败分析”（FA）两条线并行处理；
  - 两条线各自产出不同字段（QS→`report`，FA→`fa_summary`），共享输入为 `cleaned_logs`；
  - 父图作为 orchestrator 负责：清洗→扇出到子图→扇入合并→结束。

- 子图边界设计：
  - 输入边界（父→子）：仅暴露子图所需键，避免过度耦合；
  - 输出边界（子→父）：子图只发布自己负责的产出键，避免“把未修改的键也带回”的冲突；
  - 局部状态 vs 共享状态：
    - 局部状态（子图内）：子图内部中间变量、临时标记；
    - 共享状态（父图可见）：`fa_summary`、`report`、`processed_logs` 等对外承诺的产出。

- 协同编排流程（父图视角）：
  1) 预处理节点：将 `raw_logs` 清洗得到 `cleaned_logs`；
  2) 扇出：同时进入 QS 子图与 FA 子图；
  3) 扇入：统一合并来自两条线的产出，形成结构化结果；
  4) 结束：对外返回父图的输出字段。

- 合并与一致性策略：
  - 冲突来源：并行子图可能“回传”相同键（即使未修改）；
  - 解决策略：
    - 首选“输出 Schema 最小化”——只让子图输出真正修改过的键；
    - 必要时为并发写入的键定义 Reducer（如 `processed_logs` 采用累加合并）；
  - 幂等性：子图节点按“同输入多次执行不改变最终结果”的原则实现（便于重试/回放）。

- 断点与可观测性：
  - 在父图扇出前、扇入后设置断点，人工核查子图 I/O 是否符合约定；
  - 启用 xray/Studio 可视化嵌套子图，检查边界键与数据流；
  - 输出关键指标：并行耗时、去重比、合并后样本数等。

- 质量门禁与回退：
  - 门禁示例：若 QS 报告缺关键字段或 FA 总结置信度过低，则触发回退（回到清洗或补采样子图）；
  - 保底策略：当任一子图失败时，以已完成子图产出为主，标记“部分完成”并记录待办。

- 扩展与复用：
  - 将 QS/FA 抽象为“插件化子图”：固定 I/O 契约，内部实现可替换（不同模型/工具栈）；
  - 在旅行助手中迁移思路：把“检索/推荐/评审”沉淀为子图，在不同主题助手间复用；
  - 跨团队协作：子图以独立仓库/包管理，父图以版本号引用，便于灰度与回滚。

- 交付与验收清单（课堂演练）：
  - 明确父图与两个子图的 I/O 契约（输入键、输出键、键含义）；
  - 父图能在一次执行中完成清洗→并行→汇总，并在 Studio 中可视化嵌套结构；
  - 冲突键已去除或具备明确 Reducer；
  - 断点截图：扇出前/扇入后状态快照；
  - 运行报告：总耗时、并行加速比、失败与回退统计。

- 常见陷阱与规避：
  - 陷阱：子图默认把“所有键”带回父图，导致未改键也产生冲突；
    - 规避：给子图定义精简的输出 Schema；
  - 陷阱：并行写入同一个列表键导致覆盖；
    - 规避：为该键配置“追加/去重”的 Reducer，并在扇入节点统一排序；
  - 陷阱：父图对错误码/异常未收敛；
    - 规避：在扇入前做健康检查，异常分支路由至补救子图或人工断点。

- 课堂互动（3 分钟）：
  - 问：如果新增第三个“异常样本抽样”子图，你会如何改 I/O 与扇入逻辑？
  - 问：若 QS 与 FA 都需要访问外部向量库，如何避免重复调用与节省成本？
  - 问：如何为子图定义独立单测，并在父图中做集成测试？

备注：`4-BuildYourAssiant/02-sub-graph.ipynb`

---

## 13. 项目实战：多角色旅行助手（30min）
- 角色设计：
  - 规划师 Planner（拆需求/行程框架）
  - 信息员 Researcher（检索与比对）
  - 推荐官 Recommender（路线/门票/餐厅）
  - 审核官 Reviewer（质量与预算约束）
- 状态设计：
  - 输入：`user_goal, city, date_range, budget`
  - 中间：`plan, candidates, constraints, summary`
  - 输出：`final_itinerary`
- 拆分为子图：`research_subgraph`、`recommend_subgraph`、`review_subgraph`

演示任务清单（交付件）：
1) 定义 `TypedDict` 状态与各角色节点
2) 条件边：若信息不足 → 回到 `research_subgraph`
3) Reducer：合并多源候选
4) 修剪/摘要：长会话的成本控制
5) 断点：预算超标时人工审批
6) 并行：酒店/美食/景点同时检索
7) 输出：Markdown 行程单（含地图链接/预算小计）

---

## 14. 本章总结（更详细）
- 能力回顾：
  - 从零搭建 StateGraph，理解“状态-节点-边”的运行范式；
  - 掌握消息与工具链的串联方法，形成可控的调用链路；
  - 用条件边与循环实现多步决策与自我修正；
  - 通过结构化状态与 Reducer 管理多角色并发与一致性；
  - 以修剪与摘要维护长对话的上下文连续性与成本可控；
  - 接入外部记忆以实现会话持久化与跨会话复用；
  - 引入人在回路的断点审批与运行时状态编辑，确保关键路径可审可控；
  - 借助时间旅行调试快速回放、定位与回归；
  - 通过并行扇出/扇入与子图复用，获得可扩展吞吐与模块化设计。
- 典型落地场景：
  - 旅行助手、客服流程编排、合规审查流水线、企业知识问答、多工具任务协作。
- 工程化要点：
  - 明确状态 Schema 与字段所有权，减少耦合；
  - 为条件边编写可观测的判定输出（便于可视化与排错）；
  - 为并行节点定义确定性的合并策略；
  - 关键节点设置断点与审计日志；
  - 结合 LangGraph Studio 做可视化联调与回放；
  - 将长会话摘要持久化并做版本化，便于回滚与复用。
- 下一步建议：
  - 将“旅行助手”拆为可复用子图包，沉淀通用的检索/推荐/评审组件；
  - 引入队列与服务化部署（如 Docker/K8s），并结合监控/追踪体系；
  - 评估更低成本模型与向量检索，优化延迟与费用。

---

## 讲师提示（Delivery Checklist）
- 统一演示环境：`OPENAI_API_KEY`、`LANGSMITH_*` 配好；Notebook 选择 `python(agent101)`。
- 每节开场 1 张总览图，结束 1 张复盘图（状态/边/断点/并行）。
- 代码节奏：先跑通最小链路 → 再加一处条件边 → 再引入记忆/断点/并行。
- 现场 Debug 心法：优先查看状态快照与条件边返回值；用 Studio 可视化辅助定位。

---

## 参考与跳转
- Notebook 映射：
  - 基础：`1-Base/*.ipynb`
  - 状态与记忆：`2-StateAndMemory/*.ipynb`
  - 人在回路：`3-HumanInTheLoop/*.ipynb`
  - 并行与子图：`4-BuildYourAssiant/*.ipynb`
- 启动与环境：`README.md`，Studio `langgraph dev`

---

（完）


